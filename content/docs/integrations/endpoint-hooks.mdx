---
title: Endpoint Hooks
description: Configure endpoint hooks to customize request and response handling in Go Better Auth.
---

## Overview

Endpoint hooks provide a flexible way to inject custom logic into the request and response lifecycle of your authentication endpoints. The enhanced middleware now supports three distinct hooks:

- **Before Hook**: Runs before the handler. Modify the request, set custom headers/cookies, or short-circuit with a custom response.
- **Response Hook**: Intercepts and transforms the handler’s response. Use for content-type conversion, custom formatting, or error handling.
- **After Hook**: Runs asynchronously after the response is sent. Ideal for logging, metrics, or background tasks.

Hooks are injected via config, keeping your business logic decoupled from delivery concerns. All errors and important events are logged using the `slog` package for consistent, human-readable output.

**Example Use Cases:**
- Add authentication/authorization checks before handlers.
- Transform API responses (e.g. send HTML instead of JSON).
- Log requests and responses for auditing.
- Inject custom headers or cookies.

This release makes it easier to build robust, extensible APIs with clear separation of concerns and improved observability.

## Hook Context

Each hook receives an `EndpointHookContext` with structured details about the request and response:

- `Path`: Endpoint path
- `Method`: HTTP method
- `Body`: Parsed request body
- `Headers`: Request headers
- `Query`: Query parameters
- `Request`: Raw `*http.Request`
- `User`: Authenticated user (if present)
- `ResponseStatus`: Response status code
- `ResponseBody`: Response body
- `ResponseHeaders`: Response headers
- `ResponseCookies`: Response cookies

See the reference docs for full Go type definitions.

## Before Hook

Executes before the handler. Use it to:

- Validate or normalize payloads
- Block or short-circuit requests (now supports custom responses)
- Set custom headers/cookies
- Enforce rate limits or feature flags

If `Before` returns an error or a custom response, request processing is aborted and the response is sent immediately. Keep `Before` fast and non-blocking.

**Example:**

```go
import (
  "fmt"
  "strings"
  
  gobetterauthconfig "github.com/GoBetterAuth/go-better-auth/config"
  gobetterauthmodels "github.com/GoBetterAuth/go-better-auth/models"
)

config := gobetterauthconfig.NewConfig(
  gobetterauthconfig.WithEndpointHooks(
    gobetterauthmodels.EndpointHooksConfig{
      Before: func(ctx *gobetterauthmodels.EndpointHookContext) error {
        if ctx.Path == "/auth/sign-up/email" {
          email, ok := ctx.Body["email"].(string)
          if !ok || !strings.HasSuffix(email, "@example.com") {
            // Short-circuit with custom error response
            ctx.ResponseStatus = 403
            // You can convert to JSON manually here from a struct/map
            ctx.ResponseBody = []byte(`{"error":"sign-ups are restricted to @example.com emails"}`)
            return fmt.Errorf("sign-ups are restricted")
          }
        }
        // Set custom header
        ctx.ResponseHeaders["X-Custom-Header"] = []string{"CustomValue"}
        return nil
      },
    },
  ),
)
```


## Response Hook

Intercepts and transforms the handler’s response. Use cases include:

- Content-type conversion (e.g. JSON to HTML)
- Custom formatting
- Error handling
- Injecting headers/cookies

**Example:**

```go
import (
  "fmt"
  gobetterauthconfig "github.com/GoBetterAuth/go-better-auth/config"
  gobetterauthmodels "github.com/GoBetterAuth/go-better-auth/models"
)

config := gobetterauthconfig.NewConfig(
  gobetterauthconfig.WithEndpointHooks(
    gobetterauthmodels.EndpointHooksConfig{
      Response: func(ctx *gobetterauthmodels.EndpointHookContext) error {
        if ctx.Path == "/auth/me" && ctx.ResponseStatus == 200 {
          // Transform JSON response to HTML
          ctx.ResponseHeaders["Content-Type"] = []string{"text/html"}
          ctx.ResponseBody = []byte(fmt.Sprintf(`<html><body><h1>Data:</h1><pre>%s</pre></body></html>`, string(ctx.ResponseBody)))
        }
        return nil
      },
    },
  ),
)
```

## After Hook

Runs asynchronously after the response is sent. Use for:

- Structured logging (all errors/events use `slog`)
- Auditing and metrics
- Notifications or cleanup tasks

Errors in `After` are logged, not returned to the client.

**Example:**

```go
import (
  "log/slog"
  gobetterauthconfig "github.com/GoBetterAuth/go-better-auth/config"
  gobetterauthmodels "github.com/GoBetterAuth/go-better-auth/models"
)

config := gobetterauthconfig.NewConfig(
  gobetterauthconfig.WithEndpointHooks(
    gobetterauthmodels.EndpointHooksConfig{
      After: func(ctx *gobetterauthmodels.EndpointHookContext) error {
        userID := "unknown"
        if ctx.User != nil {
          userID = ctx.User.ID
        }
        slog.Info("Endpoint called", "user", userID, "path", ctx.Path, "status", ctx.ResponseStatus)
        return nil
      },
    },
  ),
)
```


## Best Practices

- Keep hooks lightweight and fast; they run on every matching request.
- Avoid blocking I/O in `Before` and `Response` hooks that would delay request handling; prefer short checks or delegate heavy work to background jobs.
- Use `Before` for authoritative control flow (validation, short-circuiting); use `Response` for response transformation; use `After` for non-blocking side effects.
- Validate input carefully in `Before` and return helpful error messages.
- Handle errors gracefully in `After` (log, don’t return).
