---
title: OAuth State Storage
description: Configure robust OAuth state storage for production deployments
---

This document describes the OAuth state storage configuration options available in Go Better Auth, designed for production deployments and multi-instance environments.

## Overview

Go Better Auth provides flexible OAuth state storage options to address the limitations of in-memory state management in production environments. The system supports:

- **Multiple Storage Backends**: In-memory, database, and Redis/secondary storage options
- **Automatic Cleanup**: Background processes to prevent memory leaks
- **Multi-Instance Support**: Shared state storage for horizontal scaling

## Quick Start

For simple applications, the default in-memory storage works out of the box:

```go
auth, err := gobetterauth.New(&domain.Config{
    Secret: "your-secret-key",
    SocialProviders: &domain.SocialProvidersConfig{
        Google: &domain.GoogleProviderConfig{
            ClientID:     "your-google-client-id",
            ClientSecret: "your-google-client-secret",
            RedirectURI:  "https://yourapp.com/auth/oauth/google/callback",
        },
    },
})
```

## Production Configuration

For production deployments, especially with multiple instances, configure persistent storage:

### Database Storage

Uses your existing database connection to store OAuth states persistently:

```go
auth, err := gobetterauth.New(&domain.Config{
    Secret: "your-secret-key",
    Database: domain.DatabaseConfig{
        Provider:         "postgres",
        ConnectionString: "your-database-connection-string",
    },
    SocialProviders: &domain.SocialProvidersConfig{
        Google: &domain.GoogleProviderConfig{
            ClientID:     "your-google-client-id",
            ClientSecret: "your-google-client-secret",
            RedirectURI:  "https://yourapp.com/auth/oauth/google/callback",
        },
        OAuthStateStorage: &domain.OAuthStateStorageConfig{
            Type:            "database",
            CleanupInterval: 5 * time.Minute,
            TTL:             10 * time.Minute,
        },
    },
})
```

### Redis Storage (via SecondaryStorage)

Use Redis or other external storage for OAuth states through SecondaryStorage:

```go
// Configure Redis storage
redisStorage := storage.NewRedisSecondaryStorage(&storage.RedisOptions{
    Addr:     "localhost:6379",
    Password: "",
    DB:       0,
})

auth, err := gobetterauth.New(&domain.Config{
    Secret:           "your-secret-key",
    SecondaryStorage: redisStorage,
    SocialProviders: &domain.SocialProvidersConfig{
        Google: &domain.GoogleProviderConfig{
            ClientID:     "your-google-client-id",
            ClientSecret: "your-google-client-secret",
            RedirectURI:  "https://yourapp.com/auth/oauth/google/callback",
        },
        OAuthStateStorage: &domain.OAuthStateStorageConfig{
            Type:            "secondary",
            CleanupInterval: 5 * time.Minute,
            TTL:             10 * time.Minute,
            KeyPrefix:       "oauth_state:",
        },
    },
})
```

## Configuration Options

The `OAuthStateStorageConfig` struct provides the following options:

### Type

- "memory" (default): In-memory storage with automatic cleanup
- "database": Persistent database storage using your configured database
- "secondary": Uses the configured SecondaryStorage (Redis, etc.)

### CleanupInterval

Specifies how often expired OAuth states are cleaned up in the background.
Default: `5 * time.Minute`.

### TTL (Time To Live)

How long OAuth states remain valid. Default: `10 * time.Minute`.

### KeyPrefix

For secondary storage, the prefix used for OAuth state keys. Default: `"oauth_state:"`.

## Operational Notes

- Ensure all instances share the same secret and storage when running multiple instances.
- Choose TTL values that balance security and user experience.

## Multi-Instance Deployment

For applications deployed across multiple instances:

1. Use persistent storage: choose "database" or "secondary" storage type.
2. Shared configuration: ensure all instances use the same secret and storage configuration.

### Example Multi-Instance Setup

```go
// Instance 1, 2, 3... all use the same configuration
auth, err := gobetterauth.New(&domain.Config{
    Secret: os.Getenv("GO_BETTER_AUTH_SECRET"), // Shared across instances
    SecondaryStorage: redisStorage,    // Shared Redis instance
    SocialProviders: &domain.SocialProvidersConfig{
        // ... provider config
        OAuthStateStorage: &domain.OAuthStateStorageConfig{
            Type: "secondary", // All instances use Redis
            TTL:  10 * time.Minute,
        },
    },
})
```

## Migration from Previous Versions

If you're upgrading from a previous version that used in-memory storage:

1. **No Code Changes Required**: The default behavior remains the same
2. **Gradual Migration**: You can switch to persistent storage without affecting existing functionality
3. **Testing**: Test the new configuration in a staging environment first

### Migration Steps

1. **Add Storage Configuration**:

   ```go
   // Add this to your existing config
   OAuthStateStorage: &domain.OAuthStateStorageConfig{
       Type: "database", // or "secondary"
   },
   ```

2. **Deploy and Monitor**: Deploy the updated configuration and monitor for any issues

3. **Verify**: Confirm that OAuth flows continue to work correctly

## Security Considerations

1. **Secret Management**: Store secrets securely using environment variables or secret management services
2. **TTL Configuration**: Balance security (shorter TTL) with user experience (longer TTL)
3. **Cleanup Monitoring**: Monitor cleanup operations to ensure they're running successfully
4. **Access Control**: Restrict access to secret rotation operations to authorized personnel only

## Troubleshooting

### Common Issues

**"State not found" errors after deployment**:

- Check that all instances use the same storage backend
- Verify secret configuration is consistent across instances

**High memory usage in production**:

- Ensure cleanup is enabled and running
- Monitor storage backend health
- Check cleanup interval configuration

**OAuth callback failures**:

- Verify TTL is appropriate for your OAuth flow duration
- Check that storage backend is accessible from all instances
- Confirm secrets are consistent across instances

### Monitoring

Monitor these metrics for OAuth state storage health:

1. **State Count**: Number of active OAuth states
2. **Cleanup Success Rate**: Percentage of successful cleanup operations
3. **Storage Errors**: Failed store/retrieve operations
4. **Error Rates**: Storage operation errors (get/set/delete)

## Performance Considerations

- In-memory: Fastest but not suitable for multi-instance deployments
- Database: Good performance with persistence, suitable for most applications
- Redis: Excellent performance with persistence, ideal for high-traffic applications

Choose the storage backend based on your traffic patterns and infrastructure requirements.
